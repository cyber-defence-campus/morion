#!/usr/bin/env python3
## -*- coding: utf-8 -*-
import IPython
from   morion.log import Logger
from   pprint     import pprint
from   triton     import ARCH, Instruction, OPCODE, OPERAND, TritonContext


class VulnerabilityAnalysis:
    """
    Different methods to identify potential security vulnerabilities.
    """

    disallow_user_inputs = False
    analysis_history = {}

    @staticmethod
    def get_path_constraints(ctx: TritonContext):
        # AST context to build constraints
        ast_ctx = ctx.getAstContext()
        ast_path_constraint = ast_ctx.equal(ast_ctx.bvtrue(), ast_ctx.bvtrue())

        # Iterate path constraints
        path_constraints = ctx.getPathConstraints()
        for path_constraint in path_constraints:

            # Consider multiway branches only
            if not path_constraint.isMultipleBranches(): continue

            # Iterate branch constraints
            for branch_constraint in path_constraint.getBranchConstraints():
                is_taken = branch_constraint['isTaken']
                constraint = branch_constraint['constraint']

                # Logical conjugate constraint of taken branch
                if is_taken:
                    ast_path_constraint = ast_ctx.land([ast_path_constraint, constraint])
        
        return ast_path_constraint

    @classmethod
    def identify_backward_slice(cls,
                                ctx: TritonContext,
                                inst: Instruction,
                                logger: Logger = Logger(),
                                tag: str = "*") -> bool:
        for sym_expr in inst.getSymbolicExpressions():
            sym_expr.setComment(str(inst))
        return True

    @classmethod
    def identify_controllable_flows(cls,
                                    ctx: TritonContext,
                                    inst: Instruction,
                                    logger: Logger = Logger(),
                                    tag: str = "*") -> bool:
        arch = ctx.getArchitecture()
        if arch != ARCH.ARM32:
            logger.error(f"[{tag:s}] Unsupported architecture!")
            return False
        regs = [("r11", "fp"), ("sp", None), ("r14", "lr"), ("pc", None)]
        for reg_name, reg_alias in regs:
            reg = ctx.getRegister(reg_name)
            # Register expression does not contain a symbolic variable
            if not ctx.isRegisterSymbolized(reg):
                continue
            reg_ast = ctx.getRegisterAst(reg)
            reg_val = ctx.getConcreteRegisterValue(reg)
            # Register cannot contain another concrete value
            if not ctx.isSat(reg_ast != reg_val):
                continue
            ast_ctx = ctx.getAstContext()
            path_constraints = cls.get_path_constraints(ctx)
            # Register cannot container another concrete value while still satifsfying the path constraints
            if not ctx.isSat(ast_ctx.land([path_constraints, reg_ast != reg_val])):
                continue
            # Potential control hijacking
            logger.warning(f"[{tag:s}] Potential control hijack due to unrestricted register '{reg_name:s}'.", color="green")
            if not cls.disallow_user_inputs:
                IPython.embed(header="Investigate potential control hijack...")
        return True

    @classmethod
    def identify_controllable_memory_reads(cls,
                                           ctx: TritonContext,
                                           inst: Instruction,
                                           logger: Logger = Logger(),
                                           tag: str = "*") -> bool:
        arch = ctx.getArchitecture()
        if arch != ARCH.ARM32:
            logger.error(f"[{tag:s}] Unsupported architecture!")
            return False

        def is_symbolic_read(reg_name: str) -> bool:
            if reg_name == "unknown":
                return False
            reg = ctx.getRegister(reg_name)
            # Register expression does not contain a symbolic variable
            if not ctx.isRegisterSymbolized(reg):
                return False
            reg_ast = ctx.getRegisterAst(reg)
            reg_val = ctx.getConcreteRegisterValue(reg)
            # Register cannot contain another concrete value
            if not ctx.isSat(reg_ast != reg_val):
                return False
            ast_ctx = ctx.getAstContext()
            path_constraints = cls.get_path_constraints(ctx)
            # Register cannot container another concrete value while still satifsfying the path constraints
            if not ctx.isSat(ast_ctx.land([path_constraints, reg_ast != reg_val])):
                return False
            logger.warning(f"[{tag:s}] Memory read from unrestricted source '{reg_name:s}'.")
            return True

        opcode = inst.getType()
        ops = inst.getOperands()
        ignore_regs = 0

        # Load register (exclusive) - singleword
        if opcode in [OPCODE.ARM32.LDR,
                      OPCODE.ARM32.LDRT,
                      OPCODE.ARM32.LDRB,
                      OPCODE.ARM32.LDRBT,
                      OPCODE.ARM32.LDRSB,
                      OPCODE.ARM32.LDRSBT,
                      OPCODE.ARM32.LDRH,
                      OPCODE.ARM32.LDRHT,
                      OPCODE.ARM32.LDRSH,
                      OPCODE.ARM32.LDRSHT,
                      OPCODE.ARM32.LDREX,
                      OPCODE.ARM32.LDREXB,
                      OPCODE.ARM32.LDREXH]:
            ignore_regs = 1
        # Load register (exclusive) - doubleword
        elif opcode in [OPCODE.ARM32.LDRD,
                        OPCODE.ARM32.LDREXD]:
            ignore_regs = 2
        if ignore_regs <= 0: return True

        # Iterate operands that constitute to the memory read target
        if len(ops) <= ignore_regs:
            logger.error(f"[{tag:s}] Unexpected number of operands: {str(inst):s}")
            return False
        is_sym_mem_read = False
        for op in ops[ignore_regs:]:
            op_type = op.getType()
            if op_type is OPERAND.REG:
                reg_name = op.getName()
                if is_symbolic_read(reg_name): is_sym_mem_read = True
            elif op_type is OPERAND.MEM:
                base_reg_name = op.getBaseRegister().getName()
                if is_symbolic_read(base_reg_name): is_sym_mem_read = True
                indx_reg_name = op.getIndexRegister().getName()
                if is_symbolic_read(indx_reg_name): is_sym_mem_read = True
                segm_reg_name = op.getSegmentRegister().getName()
                if is_symbolic_read(segm_reg_name): is_sym_mem_read = True
        if is_sym_mem_read:
            logger.debug(f"[{tag:s}] Potential arbitrary read!", color="red")
            if not cls.disallow_user_inputs:
                IPython.embed(header="Investigate potential arbitrary read...")

        return True

    @classmethod
    def identify_controllable_memory_writes(cls,
                                            ctx: TritonContext,
                                            inst: Instruction,
                                            logger: Logger = Logger(),
                                            tag: str = "*") -> bool:
        arch = ctx.getArchitecture()
        if arch != ARCH.ARM32:
            logger.error(f"[{tag:s}] Unsupported architecture!")
            return False

        def is_symbolic_write(reg_name: str) -> bool:
            if reg_name == "unknown":
                return False
            reg = ctx.getRegister(reg_name)
            # Register expression does not contain a symbolic variable
            if not ctx.isRegisterSymbolized(reg):
                return False
            reg_ast = ctx.getRegisterAst(reg)
            reg_val = ctx.getConcreteRegisterValue(reg)
            # Register cannot contain another concrete value
            if not ctx.isSat(reg_ast != reg_val):
                return False
            ast_ctx = ctx.getAstContext()
            path_constraints = cls.get_path_constraints(ctx)
            # Register cannot container another concrete value while still satifsfying the path constraints
            if not ctx.isSat(ast_ctx.land([path_constraints, reg_ast != reg_val])):
                return False
            logger.warning(f"[{tag:s}] Memory write to unrestricted destination '{reg_name:s}'.")
            return True

        opcode = inst.getType()
        ops = inst.getOperands()
        ignore_regs = 0
        
        # Store register (exclusive) - singleword
        if opcode in [OPCODE.ARM32.STR,
                      OPCODE.ARM32.STRT,
                      OPCODE.ARM32.STRB,
                      OPCODE.ARM32.STRBT,
                      OPCODE.ARM32.STRH,
                      OPCODE.ARM32.STRHT,
                      OPCODE.ARM32.STREX,
                      OPCODE.ARM32.STREXB,
                      OPCODE.ARM32.STREXH]:
            ignore_regs = 1
        # Store register (exclusive) - doubleword
        elif opcode in [OPCODE.ARM32.STRD,
                        OPCODE.ARM32.STREXD]:
            ignore_regs = 2
        if ignore_regs <= 0: return True

        # Iterate operands that constitute to the memory write target
        if len(ops) <= ignore_regs:
            logger.error(f"[{tag:s}] Unexpected number of operands: {str(inst):s}")
            return False
        is_sym_mem_write = False
        for op in ops[ignore_regs:]:
            op_type = op.getType()
            if op_type is OPERAND.REG:
                reg_name = op.getName()
                if is_symbolic_write(reg_name): is_sym_mem_write = True
            elif op_type is OPERAND.MEM:
                base_reg_name = op.getBaseRegister().getName()
                if is_symbolic_write(base_reg_name): is_sym_mem_write = True
                indx_reg_name = op.getIndexRegister().getName()
                if is_symbolic_write(indx_reg_name): is_sym_mem_write = True
                segm_reg_name = op.getSegmentRegister().getName()
                if is_symbolic_write(segm_reg_name): is_sym_mem_write = True
        if is_sym_mem_write:
            logger.debug(f"[{tag:s}] Potential arbitrary write!", color="red")
            if not cls.disallow_user_inputs:
                IPython.embed(header="Investigate potential arbitrary write..")

        return True

    @classmethod
    def identify_controllable_branches(cls,
                                       ctx: TritonContext,
                                       inst: Instruction,
                                       logger: Logger = Logger(),
                                       tag: str = "*") -> bool:
        curr_inst_addr = inst.getAddress()
        next_inst_addr = ctx.getConcreteRegisterValue(ctx.registers.pc)

        # AST context to build constraints
        ast_ctx = ctx.getAstContext()
        ast_path_constraint = ast_ctx.equal(ast_ctx.bvtrue(), ast_ctx.bvtrue())

        # Iterate path constraints
        path_constraints = ctx.getPathConstraints()
        for path_constraint in path_constraints:

            # Consider multiway branches only
            if not path_constraint.isMultipleBranches(): continue

            # Iterate branch constraints
            for branch_constraint in path_constraint.getBranchConstraints():
                is_taken = branch_constraint['isTaken']
                src_addr = branch_constraint['srcAddr']
                dst_addr = branch_constraint['dstAddr']
                constraint = branch_constraint['constraint']

                # Branch constraint of current instruction
                if curr_inst_addr == src_addr:
                    # Branch constraint of non-taken branch
                    if next_inst_addr != dst_addr:

                        # Consider each branch only once
                        branch = f"0x{src_addr:x} --> 0x{dst_addr:x}"
                        if branch in cls.analysis_history: continue
                        logger.info(f"[{tag:s}] Exploring new branch {branch:s}...", color="green")

                        # Find a model
                        model_summary = []
                        ast_path_constraint = ast_ctx.land([ast_path_constraint, constraint])
                        while True:
                            # Ask the solver for a model
                            model = sorted(list(ctx.getModel(ast_path_constraint).items()), key=lambda t: t[1].getVariable())

                            # Find concrete values for all symbolic variables
                            if len(model_summary) >= len(model): break
                            sym_var_id, solver_model = model[len(model_summary)]

                            # Symbolic variable and AST
                            sym_var = ctx.getSymbolicVariable(sym_var_id)
                            sym_ast = ast_ctx.variable(sym_var)

                            # Evaluate model
                            try:
                                key = int(sym_var.getAlias())
                                is_mem = True
                            except ValueError:
                                key = sym_var.getAlias()
                                is_mem = False
                            finally:
                                value = solver_model.getValue()

                            # Input text
                            text = "MEM: 0x{:x}=0x{:x}" if is_mem else "REG: {:s}=0x{:x}"
                            if not cls.disallow_user_inputs:
                                i_text  = text
                                i_text += " (Press ENTER to accept the proposed value or specify a new one)\n"
                                i_text += "MEM: 0x{:x}=0x" if is_mem else "REG: {:s}=0x"
                                i_text  = i_text.format(key, value, key)

                                # Adjust model value
                                while True:
                                    # Ask for user input
                                    new_value = "0x" + input(i_text)
                                    # User accepted the proposed value
                                    if new_value == "0x": break
                                    # Ensure that the user-specified value reaches the new branch
                                    try:
                                        new_value = int(new_value, base=16)
                                        ast_branch = ast_ctx.land([ast_path_constraint, sym_ast==new_value])
                                        if ctx.isSat(ast_branch):
                                            value = new_value
                                            if input("Accept [y]/[N]? ") == "y": break
                                        else:
                                            logger.warning(
                                                f"[{tag:s}] The specified value does not reach the targeted branch!")
                                    except ValueError:
                                        logger.warning(f"[{tag:s}] The specified value is invalid!")
                                        
                            # Store summary information
                            model_summary.append(text.format(key, value))
                            ast_path_constraint = ast_ctx.land([ast_path_constraint, sym_ast==value])

                        # Store explored branch
                        if model_summary:
                            cls.analysis_history[branch] = model_summary
                            if not cls.disallow_user_inputs:
                                input("(Press ENTER to continue)")
                        
                        # Debug output
                        logger.debug(f"[{tag:s}] Summary of how to trigger branch {branch:s}:")
                        model_summary.sort()
                        for line in model_summary:
                            logger.debug(f"[{tag:s}] \t{line:s}")
                        logger.info(f"[{tag:s}] ... new branch {branch:s} explored.", color="green")
                        
                # Branch constraint of previous instruction
                elif is_taken:
                    ast_path_constraint = ast_ctx.land([ast_path_constraint, constraint])
            
        return True

    @classmethod
    def identify_controllable_paths(cls,
                                    ctx: TritonContext,
                                    inst: Instruction,
                                    logger: Logger = Logger(),
                                    tag: str = "*") -> bool:
        curr_inst_addr = inst.getAddress()
        next_inst_addr = ctx.getConcreteRegisterValue(ctx.registers.pc)

        # AST context to build constraints
        ast_ctx = ctx.getAstContext()
        ast_path_constraint = ast_ctx.equal(ast_ctx.bvtrue(), ast_ctx.bvtrue())
        path = []

        # Iterate path constraints
        path_constraints = ctx.getPathConstraints()
        for path_constraint in path_constraints:

            # Consider multiway branches only
            if not path_constraint.isMultipleBranches(): continue

            # Iterate branch constraints
            for branch_constraint in path_constraint.getBranchConstraints():
                is_taken = branch_constraint['isTaken']
                src_addr = branch_constraint['srcAddr']
                dst_addr = branch_constraint['dstAddr']
                constraint = branch_constraint['constraint']

                # Branch constraint of current instruction
                if curr_inst_addr == src_addr:
                    # Branch constraint of non-taken branch
                    if next_inst_addr != dst_addr:

                        # Consider each path only once
                        path.append(f"0x{src_addr:x} --> 0x{dst_addr:x}")
                        path_str = ", ".join(path)
                        if path_str in cls.analysis_history: continue

                        logger.info(f"[{tag:s}] Exploring new path ({len(path)-1:d} branches) --> 0x{dst_addr:x}",
                                       color="green")

                        # Find a model
                        model_summary = []
                        ast_path_constraint = ast_ctx.land([ast_path_constraint, constraint])
                        while True:
                            # Ask the solver for a model
                            model = sorted(list(ctx.getModel(ast_path_constraint).items()), key=lambda t: t[1].getVariable())
                            # Find concrete values for all symbolic variables
                            if len(model_summary) >= len(model): break
                            sym_var_id, solver_model = model[len(model_summary)]
                            
                            # Symbolic variable and AST
                            sym_var = ctx.getSymbolicVariable(sym_var_id)
                            sym_ast = ast_ctx.variable(sym_var)

                            # Evaluate model
                            try:
                                key = int(sym_var.getAlias())
                                is_mem = True
                            except ValueError:
                                key = sym_var.getAlias()
                                is_mem = False
                            finally:
                                value = solver_model.getValue()

                            # Input text
                            text = "MEM: 0x{:x}=0x{:x}" if is_mem else "REG: {:s}=0x{:x}"
                            if not cls.disallow_user_inputs:
                                i_text  = text
                                i_text += " (Press ENTER to accept the proposed value or specify a new one)\n"
                                i_text += "MEM: 0x{:x}=0x" if is_mem else "REG: {:s}=0x"
                                i_text  = i_text.format(key, value, key)

                                # Adjust model value
                                while True:
                                    # Ask for user input
                                    new_value = "0x" + input(i_text)
                                    # User accepted the proposed value
                                    if new_value == "0x": break
                                    # Ensure that the user-specified value reaches the new branch
                                    try:
                                        new_value = int(new_value, base=16)
                                        ast_branch = ast_ctx.land([ast_path_constraint, sym_ast==new_value])
                                        if ctx.isSat(ast_branch):
                                            value = new_value
                                            if input("Accept [y]/[N]? ") == "y": break
                                        else:
                                            logger.warning(
                                                f"[{tag:s}] The specified value does not reach the targeted branch!")
                                    except ValueError:
                                        logger.warning(f"[{tag:s}] The specified value is invalid!")

                            # Store summary information
                            model_summary.append(text.format(key, value))
                            ast_path_constraint = ast_ctx.land([ast_path_constraint, sym_ast==value])

                        # Store explored branch
                        if model_summary:
                            cls.analysis_history[path_str] = model_summary
                            if not cls.disallow_user_inputs:
                                input("(Press ENTER to continue)")
                        logger.info(f"[{tag:s}] ... new path explored.", color="green")
                        
                # Branch constraint of previous instruction
                elif is_taken:
                    path.append(f"0x{src_addr:x} --> 0x{dst_addr:x}")
                    ast_path_constraint = ast_ctx.land([ast_path_constraint, constraint])
            
        return True
