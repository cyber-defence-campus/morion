#!/usr/bin/env python3
## -*- coding: utf-8 -*-
import IPython
from   morion.log import Logger
from   triton     import ARCH, Instruction, OPCODE, OPERAND, TritonContext


def identify_backward_slice(ctx: TritonContext,
                            inst: Instruction,
                            logger: Logger = Logger()) -> bool:
    for sym_expr in inst.getSymbolicExpressions():
        sym_expr.setComment(str(inst))
    return True


def identify_controllable_flows(ctx: TritonContext,
                                inst: Instruction,
                                logger: Logger = Logger()) -> bool:
    arch = ctx.getArchitecture()
    if arch != ARCH.ARM32:
        logger.error("Unsupported architecture!")
        return False
    regs = [("r11", "fp"), ("sp", None), ("r14", "lr"), ("pc", None)]
    for reg_name, reg_alias in regs:
        reg = ctx.getRegister(reg_name)
        if not ctx.isRegisterSymbolized(reg): continue
        logger.debug(f"Expression of register '{reg_name:s}' contains a symbolic variable.", color="yellow")
        reg_ast = ctx.getRegisterAst(reg)
        # Direct control flow change
        if inst.isControlFlow():
            if inst.isConditionTaken():
                taken_addr = ctx.getConcreteRegisterValue(ctx.registers.pc)
            else:
                ops = inst.getOperands()
                if len(ops) < 1:
                    logger.error(f"Control flow change with unexpected number of operands!")
                    return False
                op = ops[-1]
                if op.getType() != OPERAND.IMM:
                    logger.error(f"Control flow change with unexpected operand type!")
                    return False
                taken_addr = op.getValue()
            fallt_addr = inst.getNextAddress()
            # Control flow can reach targets other than the taken or fallthrough addresses
            ast_ctx = ctx.getAstContext()
            ast_cond = ast_ctx.land([reg_ast != taken_addr, reg_ast != fallt_addr])
            if ctx.isSat(ast_cond):
                logger.debug("Direct control flow change with unrestricted target!", color="red")
                IPython.embed(header="Investigate potential control hijack...")
            else:
                logger.debug("Direct control flow change with restricted target.", color="green")
        # Indirect control flow change
        else:
            reg_value = ctx.getConcreteRegisterValue(reg)
            if ctx.isSat(reg_ast != reg_value):
                logger.debug("Indirect control flow change with unrestricted target!", color="red")
                IPython.embed(header="Investigate potential control hijack...")
            else:
                logger.debug("Indirect control flow change with restricted target.", color="green")
    return True


def identify_controllable_memory_reads(ctx: TritonContext,
                                       inst: Instruction,
                                       logger: Logger = Logger()) -> bool:
    arch = ctx.getArchitecture()
    if arch != ARCH.ARM32:
        logger.error("Unsupported architecture!")
        return False

    def is_symbolic_read(reg_name: str) -> bool:
        if reg_name == "unknown": return False
        reg = ctx.getRegister(reg_name)
        if ctx.isRegisterSymbolized(reg):
            reg_ast = ctx.getRegisterAst(reg)
            reg_value = ctx.getConcreteRegisterValue(reg)
            if ctx.isSat(reg_ast != reg_value):
                logger.warning(f"Memory read from unrestricted source '{reg_name:s}'.")
                return True
            return False

    opcode = inst.getType()
    ops = inst.getOperands()
    ignore_regs = 0

    # Load register (exclusive) - singleword
    if opcode in [OPCODE.ARM32.LDR,
                  OPCODE.ARM32.LDRT,
                  OPCODE.ARM32.LDRB,
                  OPCODE.ARM32.LDRBT,
                  OPCODE.ARM32.LDRSB,
                  OPCODE.ARM32.LDRSBT,
                  OPCODE.ARM32.LDRH,
                  OPCODE.ARM32.LDRHT,
                  OPCODE.ARM32.LDRSH,
                  OPCODE.ARM32.LDRSHT,
                  OPCODE.ARM32.LDREX,
                  OPCODE.ARM32.LDREXB,
                  OPCODE.ARM32.LDREXH]:
        ignore_regs = 1
    # Load register (exclusive) - doubleword
    elif opcode in [OPCODE.ARM32.LDRD,
                    OPCODE.ARM32.LDREXD]:
        ignore_regs = 2
    if ignore_regs <= 0: return True

    # Iterate operands that constitute to the memory read target
    if len(ops) <= ignore_regs:
        logger.error(f"Unexpected number of operands: {str(inst):s}")
        return False
    is_sym_mem_read = False
    for op in ops[ignore_regs:]:
        op_type = op.getType()
        if op_type is OPERAND.REG:
            reg_name = op.getName()
            if is_symbolic_read(reg_name): is_sym_mem_read = True
        elif op_type is OPERAND.MEM:
            base_reg_name = op.getBaseRegister().getName()
            if is_symbolic_read(base_reg_name): is_sym_mem_read = True
            indx_reg_name = op.getIndexRegister().getName()
            if is_symbolic_read(indx_reg_name): is_sym_mem_read = True
            segm_reg_name = op.getSegmentRegister().getName()
            if is_symbolic_read(segm_reg_name): is_sym_mem_read = True
    if is_sym_mem_read:
        IPython.embed(header="Investigate potential arbitrary read...")

    return True


def identify_controllable_memory_writes(ctx: TritonContext,
                                        inst: Instruction,
                                        logger: Logger = Logger()) -> bool:
    arch = ctx.getArchitecture()
    if arch != ARCH.ARM32:
        logger.error("Unsupported architecture!")
        return False

    def is_symbolic_write(reg_name: str) -> bool:
        if reg_name == "unknown": return False
        reg = ctx.getRegister(reg_name)
        if ctx.isRegisterSymbolized(reg):
            reg_ast = ctx.getRegisterAst(reg)
            reg_value = ctx.getConcreteRegisterValue(reg)
            if ctx.isSat(reg_ast != reg_value):
                logger.warning(f"Memory write to unrestricted destination '{reg_name:s}'.")
                return True
            return False

    opcode = inst.getType()
    ops = inst.getOperands()
    ignore_regs = 0
    
    # Store register (exclusive) - singleword
    if opcode in [OPCODE.ARM32.STR,
                  OPCODE.ARM32.STRT,
                  OPCODE.ARM32.STRB,
                  OPCODE.ARM32.STRBT,
                  OPCODE.ARM32.STRH,
                  OPCODE.ARM32.STRHT,
                  OPCODE.ARM32.STREX,
                  OPCODE.ARM32.STREXB,
                  OPCODE.ARM32.STREXH]:
        ignore_regs = 1
    # Store register (exclusive) - doubleword
    elif opcode in [OPCODE.ARM32.STRD,
                    OPCODE.ARM32.STREXD]:
        ignore_regs = 2
    if ignore_regs <= 0: return True

    # Iterate operands that constitute to the memory write target
    if len(ops) <= ignore_regs:
        logger.error(f"Unexpected number of operands: {str(inst):s}")
        return False
    is_sym_mem_write = False
    for op in ops[ignore_regs:]:
        op_type = op.getType()
        if op_type is OPERAND.REG:
            reg_name = op.getName()
            if is_symbolic_write(reg_name): is_sym_mem_write = True
        elif op_type is OPERAND.MEM:
            base_reg_name = op.getBaseRegister().getName()
            if is_symbolic_write(base_reg_name): is_sym_mem_write = True
            indx_reg_name = op.getIndexRegister().getName()
            if is_symbolic_write(indx_reg_name): is_sym_mem_write = True
            segm_reg_name = op.getSegmentRegister().getName()
            if is_symbolic_write(segm_reg_name): is_sym_mem_write = True
    if is_sym_mem_write:
        IPython.embed(header="Investigate potential arbitrary write..")

    return True
